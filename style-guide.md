## 1. Терминология
В рамках этого руководства определены следующие термины:

Термин класс используется для обозначения «обычного» класса, перечислений, интерфейса или типа аннотации (&commat;interface)    
Термин член класса используется для обозначения вложенного класса, поля, метода или конструктора, то есть для всех элементов класса высокого уровня, кроме блоков инициализации и комментариев

Остальная терминология будет даваться по мере необходимости в разных местах данного руководства.

## 2. Исходный файл. Основы

### 2.1 Имя файла
Имя исходного файла состоит из имени одного конкретного класса высшего уровня, находящегося в нем. Имя является регистрозависимым и заканчивается расширением .java

### 2.2 Кодировка файла: UTF-8
Для файлов с кодом используется кодировка UTF-8.

## 3. Структура исходного файла

Исходный файл состоит из следующих элементов (в указанном порядке):

Информация о лицензии или авторских правах, если имеется   
Объявление пакета   
Объявление импортов   
Объявление класса   

Ровно одна пустая строка разделяет каждый присутствующий раздел.

### 3.1 Информация о лицензии или авторских правах, если имеется
Информация о лицензии или авторских правах должна быть размещена в том файле, к которому она относится.

### 3.2 Объявление пакета
Пакет объявляется без переноса строки. Ограничение на ширину строки (Раздел 4.4) на объявление пакета не распространяется.

### 3.3 Объявление импортов
Импорты упорядочиваются следующим образом:
- Все статические импорты размещаются и группируются в одном блоке   
- Все не статические импорты размещаются в другом блоке
Импорты объявляются без переноса строки, ограничение на ширину строки на них не распространяется.

### 3.4 Объявление класса
- Каждый класс верхнего уровня располагается в своем исходном файле
- Порядок, выбираемый при расположении членов и блоков инициализации класса, может оказать большое влияние на легкость понимания кода. Однако для этого не существует единого правильного рецепта: разные классы могут упорядочивать свое содержимое по-разному. Важно то, чтобы у каждого класса был такой логический порядок расположения содержимого, который позволил бы программисту, сопровождающему этот код, объяснить его
- Когда у класса есть несколько конструкторов или методов с одинаковым именем, они должны располагаться последовательно, без вставок другого кода между ними

## 4. Форматирование
**Терминология**

Тело класса, метода или конструктора относится к блочной конструкции.

### 4.1 Фигурные скобки
Фигурные скобки используются везде, где они могут быть использованы. Фигурные скобки используются в if, else, for, while и do-while, даже если тело выражения пустое или содержит лишь одну строку кода.

### 4.2 Одно выражение на каждую строку
Каждое выражение завершается переходом на новую строку.

### 4.3 Ограничение ширины строки в 100 символов
Java-код имеет ограничение в 100 символов по ширине строки. Под «символом» понимается любой из элементов Unicode

Исключения:
- Строки, в которых соблюдение ограничения по ширине невозможно (например, длинная ссылка URL в Javadoc или длинная JSNI-ссылка на метод)
- Объявления package и import
- Строки с командами в комментариях, которые могут быть скопированы и вставлены для выполнения в терминале

### 4.4 Перенос строки
Когда код, который в другом случае мог бы быть расположен на одной строке, разделяется на несколько строк, это явление называется переносом строки.

Не существует общепринятой однозначной формулы, определяющей, как именно надо делать перенос строки в каждой ситуации. Очень часто существует несколько способов переноса строки с одним и тем же фрагментом кода.

Обычно перенос делается во избежание переполнения строки по ширине. Но даже если код остался бы в пределах разрешенной ширины, то и он, по решению автора, может быть перенесен на новую строку.

### 4.5 Отступы
Одна пустая строка всегда ставится:

1. Между следующими друг за другом членами или инициализаторами класса: полями, конструкторами, методами, вложенными классами, статическими и динамическими блоками инициализации

Исключения:
- Пустая строка между двумя последовательными полями (без кода между ними) используется опционально. При необходимости пустые строки используются для логического группирования полей
- Пустые строки между константами класса enum

2. В соответствии с другими разделами данного документа (например, с Разделом 3 и Разделом 3.3)

Пустая строка также может быть использована повсеместно для повышения читаемости кода, например, между выражениями для организации кода в логические подразделы. Пустая строка перед первым членом класса, или блоком инициализации, или после последнего члена, или блока инициализации класса не приветствуется, но и не возбраняется.

Несколько последовательных пустых строк делать разрешается, но это не необходимо и не приветствуется.
____
Горизонтальное выравнивание не требуется никогда. 

Горизонтальное выравнивание — это практика добавления различного числа дополнительных пробелов в вашем коде с целью сделать так, чтобы определенные элементы были расположены под другими элементами с предыдущей строки.

Эта практика разрешена, но ее использование не требуется данным руководством. Также нет необходимости поддерживать соблюдение выравнивания в тех участках кода, где оно уже было применено.

Пример с выравниванием и без него:

```
private int x; // хорошо
private Color color; // и это тоже

private int   x;      // разрешено, но при редактировании в будущем
private Color color;  // можно оставить без выравнивания
```

Выравнивание способствует читаемости кода, но создает проблемы с поддержкой такого кода в будущем. Допустим, требуется изменить только одну строку. Это изменение может исказить форматирование ранее принятого кода, что допускается. Но, скорее всего, программист (возможно, вы) начнет корректировку количества пробелов на рядом стоящих строках, что, возможно, запустит целую череду исправлений. Изменение одной строки может активировать «взрывную волну» из бессмысленного труда (в худшем случае). Или, в лучшем случае, приведет к искажению информации в истории версий, ухудшит чтение кода и обострит конфликты слияния.

### 4.6 Группирующие скобки рекомендованы
Допускается не ставить группирующие скобки только тогда, когда автор кода и рецензент согласны в том, что нет разумной вероятности, что код будет неверно истолкован без скобок, и при этом скобки не облегчили бы его чтение. Нет причины полагать, что каждый, кто читает код, помнит наизусть всю таблицу приоритетов использования операторов Java.

## 5. Именование
Идентификаторы используют только буквы и цифры ASCII и, в некоторых отмеченных ниже случаях, подчеркивания.

Таким образом, каждому действительному имени идентификатора соответствует регулярное выражение \w+ (буквенно-цифровой символ, встречающийся один или более раз).

Стилю данного руководства не соответствуют имена, использующие специальные суффиксы или префиксы, например: name_, mName, s_name или kName.

### 5.1 Имена пакетов
Имена пакетов должны быть записаны в нижнем регистре, без использования camelCase или подчеркиваний.

### 5.2 Имена классов
Имена классов пишутся в стиле UpperCamelCase (с заглавной первой буквой).

Имена классов обычно являются существительными или словосочетаниями с существительными. Например, Character или ImmutableList.

Имена интерфейсов также могут быть существительными или словосочетаниями с существительными (например, List), но иногда могут быть и прилагательными или сочетаниями прилагательных (например, Readable).

Не существует конкретных правил или даже устоявшихся соглашений для именования типов аннотаций.

Тестовые классы носят имя, которое начинается с имени класса, который они тестируют, и заканчивается словом Test. Например, HashTest или HashIntegrationTest.

### 5.3 Имена методов
Имена методов пишутся в стиле lowerCamelCase.

Имена методов обычно являются глаголами или словосочетаниями с глаголами. Например, sendMessage или stop. Подчеркивания могут присутствовать в именах тестовых методов JUnit для разделения логических компонентов в имени. При этом каждый компонент пишется в стиле lowerCamelCase. Не существует единственно верного пути в именовании тестовых методов.

### 5.4 Имена констант
Константы именуются в стиле CONSTANT_CASE: все буквы в верхнем регистре, каждое слово отделено от следующего подчеркиванием.